## 핵심 내용

YDKJS 를 다시 읽으면서 가장 기억에 꽂혔던 개념은 this는 동적 컨텍스트이고 스코프는 정적 컨텍스트라는 것이다.

자바스크립트에서 함수는 일급값이기 때문에 어느 곳이든지 값으로 이동되어 쓰일 수 있다. 이 때 함수의 동작에 문제가 없게 하려면 함수가 동작하는 데 필요한 컨텍스트 정보가 소실되거나 잘못된 값이 들어가도록 하면 안된다.

자바스크립트에서는 함수가 필요한 곳에서 유연하게 다른 동작을 할 수 있도록 동적으로 컨텍스트를 설정할 수 있는 this 라는 수단과 어느 곳으로 이동되어 쓰이더라도 반드시 기억하고 있어야하는 정적인 컨텍스트를 가질 수 있도록 클로저라는 수단을 제공한다.

## this에 대해

자바스크립트는 거의 모든것이 객체인데, 이러한 객체들 사이에는 프로토타입이라는 객체간의 연결관계가 존재한다. 객체에서 어떤 속성을 찾을 때 필요한 속성이 없다면 프로토타입을 타고 필요한 속성들을 찾게 된다. 그리고 this는 그 연결관계에 있는 객체들을 관통하는(공유하는) 컨텍스트를 의미한다.

this를 바인딩하는 방법에는 call, apply, bind 메서드를 사용한 명시적 바인딩과 "함수의 호출방식"에 따라 결정되는 암시적 바인딩이 있다.

```js
const homework = {
  study() {
    // 동적인 컨텍스트인 this를 쓰고 있으니, this 바인딩을 제대로 해주어야 올바른 동작을 할 수 있다.
    console.log(`${this.topic}을 공부하세요.`);
  },
};

// 프로토타입 설정을 통해 homework과 jsHomework과의 연결관계가 설정되었다.
const jsHomework = Object.create(homework);
jsHomework.topic = "JS";
/*
1. 함수의 호출 방식에 따라 this가 jsHomework에 암시적으로 바인딩 되었다.
2. 프로토타입을 따라 jsHomework에 없는 study()를 homework에서 찾아 호출한다.
3. this는 객체간 연결관계를 관통하기 때문에 this.topic은 jsHomework.topic 을 사용하게 된다.
*/
jsHomework.study(); // JS을/를 공부하세요.
```

## 클로저에 대해

자바스크립트는 함수가 이곳 저곳 옮겨져 쓰이더라도 함수 본래의 동작에 필요한 컨텍스트를 기억할 수 있게 한다.
그 방식은 아주 간단한데, 함수를 선언할 때 함수 바깥 스코프의 변수를 캡쳐해서 사용하면 그 함수는 어느곳으로 이동되어 쓰이더라도 캡쳐한 변수를 기억하고 사용할 수 있게 된다.

```js
function makeCounter() {
  let count = 0;

  return function getCurrent() {
    // 함수의 선언 시점에 바깥 스코프의 count 변수를 캡쳐해서 사용
    count = count + 1;
    return count;
  };
}

/*
makeCounter 함수가 실행이 완료된 시점에서 count는 메모리에서 사라지는 것이 맞으나
클로저 효과 때문에 count는 메모리에서 유지되어 getCurrent의 정적 컨텍스트로서 사용된다.
*/
const hits = makeCounter();
hits(); // 1
hits(); // 2
hits(); // 3
```

## 자바스크립트는 컴파일 언어?

내용을 요약하기는 어렵고 설명이 잘 되어 있는 아티클을 소개한다. 한번씩 읽어보는 것을 추천한다.

[V8 엔진은 어떻게 내 코드를 실행하는 걸까?](https://evan-moon.github.io/2019/06/28/v8-analysis/)

+++)

클로저에 관련된 부분만 짚어보자면 애초에 V8 엔진이 코드를 파싱하는 과정에서 어떤 함수가 어떤 스코프 체인을 통해 어떤 변수 식별 공간을 사용할 수 있는지가 정적으로 스코프 트리로 만들어지고 함수는 이 스코프 트리를 참고하여 변수를 찾게 된다. 스코프는 정적 컨텍스트다. 라는 멘탈모델에도 잘 맞는거 같다.
